<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>เว็บเปรียบเทียบสีจากภาพกับสีต้นแบบ</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, sans-serif; margin: 20px; line-height: 1.5; color: black; }
    h1 { font-size: 1.4rem; margin-bottom: 12px; }
    .grid { display: grid; grid-template-columns: 1fr 300px; gap: 20px; align-items: start; }
    canvas { border: 1px solid #ccc; max-width: 100%; height: auto; cursor: crosshair; background: #fff; }
    .panel { border: 1px solid #e5e5e5; padding: 12px; background: #fafafa; }
    label { display:block; margin: 8px 0 4px; }
    input[type="text"], input[type="number"], select { width: 100%; padding: 6px; box-sizing: border-box; }
    .swatches { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .swatch { width: 40px; height: 40px; border: 1px solid #ddd; }
    .result { margin-top: 10px; padding: 10px; background: #fff; border: 1px dashed #ddd; }
    .tip { font-size: 0.9rem; color: #555; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    button { padding: 6px 10px; }
  </style>
</head>
<body>

<h1>เว็บเปรียบเทียบสีจากภาพกับสีต้นแบบสองสี</h1>

<div class="grid">
  <!-- Left: Image and canvas -->
  <div>
    <div class="panel">
      <label>อัพโหลดภาพ (PNG/JPG)</label>
      <input type="file" id="fileInput" accept="image/*" />
      <p class="tip">คลิกบนภาพเพื่อเลือกจุดสี หรือเปิดโหมดเฉลี่ยรัศมีเพื่อเก็บค่าเฉลี่ยรอบจุด</p>

      <div class="row">
        <label class="row"><input type="checkbox" id="avgMode" /> เปิดโหมดเฉลี่ยรัศมี</label>
        <label style="min-width:160px;">รัศมีเฉลี่ย (พิกเซล)
          <input type="number" id="radius" value="5" min="1" max="100" />
        </label>
      </div>

      <canvas id="canvas" width="800" height="500"></canvas>
    </div>
  </div>

  <!-- Right: Controls -->
  <div>
    <div class="panel">
      <h2 style="font-size:1.1rem;">ตั้งค่าสีต้นแบบ</h2>
       <label>สี A: <input type="color" id="refA" value="#FF0000"></label>
      <label>สี B: <input type="color" id="refB" value="#00FF00"></label>
      <div>
        <div class="swatch" id="swatchA"></div>
        <div class="swatch" id="swatchB"></div>
     <h3>กำหนดค่าตัวเลขของสีต้นแบบ</h3>
<label>ค่า A: <input type="number" id="valA" value="1"></label>
<label>ค่า B: <input type="number" id="valB" value="5"></label>

      <label style="margin-top:10px;">โหมดคำนวณ Delta E</label>
      <select id="deltaMode">
        <option value="76">CIE76 (พื้นฐาน)</option>
        <option value="2000">CIEDE2000 (แม่น)</option>
      </select>

      <div class="panel" style="margin-top:10px;">
        <div class="row">
          <strong>สีจากภาพที่เลือก:</strong>
          <div class="swatch" id="swatchPick" title="picked"></div>
          <div id="pickedHex"></div>
        </div>
        <div class="result" id="result">
          <strong>ผลลัพธ์:</strong>
          <div>ΔE (A): -</div>
          <div>ΔE (B): -</div>
          <div>ใกล้กับ: -</div>
        </div>
      </div>

      <div class="tip">
        เคล็ดลับ: ถ้าภาพมืด/สว่างมาก ให้ใช้โหมดเฉลี่ยรัศมีเพื่อลดผลกระทบจาก noise และแสง
      </div>
    </div>
  </div>
</div>

<script>
/* ---------- Helpers ---------- */
function clamp(v, min=0, max=255){ return Math.min(max, Math.max(min, v)); }
function hexToRgb(hex) {
  const m = String(hex).trim().match(/^#?([a-fA-F0-9]{6})$/);
  if (!m) return null;
  const n = parseInt(m[1], 16);
  return { r: (n>>16)&255, g: (n>>8)&255, b: n&255 };
}
function rgbToHex({r,g,b}) {
  return '#' + [r,g,b].map(x => clamp(Math.round(x)).toString(16).padStart(2,'0')).join('').toUpperCase();
}

/* sRGB -> linear */
function srgbToLinear(c) {
  c = c / 255;
  return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
}

/* linear RGB -> XYZ (D65) */
function rgbToXyz(r,g,b) {
  const R = srgbToLinear(r), G = srgbToLinear(g), B = srgbToLinear(b);
  const X = R*0.4124564 + G*0.3575761 + B*0.1804375;
  const Y = R*0.2126729 + G*0.7151522 + B*0.0721750;
  const Z = R*0.0193339 + G*0.1191920 + B*0.9503041;
  return {X, Y, Z};
}

/* XYZ -> LAB (D65 reference white) */
function xyzToLab(X, Y, Z) {
  const Xn = 0.95047, Yn = 1.00000, Zn = 1.08883;
  let x = X / Xn, y = Y / Yn, z = Z / Zn;
  const f = t => (t > 0.008856) ? Math.pow(t, 1/3) : (7.787*t + 16/116);
  const fx = f(x), fy = f(y), fz = f(z);
  const L = (y > 0.008856) ? (116*Math.pow(y,1/3)-16) : (903.3*y);
  const a = 500*(fx - fy);
  const b = 200*(fy - fz);
  return {L, a, b};
}

function rgbToLab({r,g,b}) {
  const {X,Y,Z} = rgbToXyz(r,g,b);
  return xyzToLab(X,Y,Z);
}

/* Delta E CIE76 */
function deltaE76(L1,a1,b1, L2,a2,b2) {
  const dL = L1-L2, da=a1-a2, db=b1-b2;
  return Math.sqrt(dL*dL + da*da + db*db);
}

/* Delta E CIEDE2000 */
function deltaE2000(L1,a1,b1, L2,a2,b2) {
  // Based on Sharma et al. 2005
  const rad2deg = r => r * (180/Math.PI);
  const deg2rad = d => d * (Math.PI/180);

  const C1 = Math.sqrt(a1*a1 + b1*b1);
  const C2 = Math.sqrt(a2*a2 + b2*b2);
  const avgC = (C1 + C2) / 2;
  const G = 0.5 * (1 - Math.sqrt(Math.pow(avgC,7) / (Math.pow(avgC,7) + Math.pow(25,7))));
  const a1p = (1+G) * a1;
  const a2p = (1+G) * a2;
  const C1p = Math.sqrt(a1p*a1p + b1*b1);
  const C2p = Math.sqrt(a2p*a2p + b2*b2);
  const h1p = Math.atan2(b1, a1p) + (Math.atan2(b1, a1p) < 0 ? 2*Math.PI : 0);
  const h2p = Math.atan2(b2, a2p) + (Math.atan2(b2, a2p) < 0 ? 2*Math.PI : 0);

  const dLp = L2 - L1;
  const dCp = C2p - C1p;
  let dhp = h2p - h1p;
  if (dhp > Math.PI) dhp -= 2*Math.PI;
  if (dhp < -Math.PI) dhp += 2*Math.PI;
  const dHp = 2*Math.sqrt(C1p*C2p) * Math.sin(dhp/2);

  const avgLp = (L1 + L2) / 2;
  const avgCp = (C1p + C2p) / 2;
  let avgHp = (h1p + h2p) / 2;
  if (Math.abs(h1p - h2p) > Math.PI) {
    avgHp = (h1p + h2p < 2*Math.PI) ? (h1p + h2p + 2*Math.PI)/2 : (h1p + h2p - 2*Math.PI)/2;
  }

  const T = 1
    - 0.17 * Math.cos(avgHp - deg2rad(30))
    + 0.24 * Math.cos(2*avgHp)
    + 0.32 * Math.cos(3*avgHp + deg2rad(6))
    - 0.20 * Math.cos(4*avgHp - deg2rad(63));

  const dRo = deg2rad(30) * Math.exp(- Math.pow((rad2deg(avgHp) - 275) / 25, 2));
  const Rc = 2 * Math.sqrt(Math.pow(avgCp, 7) / (Math.pow(avgCp, 7) + Math.pow(25, 7)));
  const Rt = -Rc * Math.sin(2 * dRo);

  const Sl = 1 + (0.015 * Math.pow(avgLp - 50, 2)) / Math.sqrt(20 + Math.pow(avgLp - 50, 2));
  const Sc = 1 + 0.045 * avgCp;
  const Sh = 1 + 0.015 * avgCp * T;

  const Kl = 1, Kc = 1, Kh = 1;

  const dE = Math.sqrt(
    Math.pow(dLp / (Kl * Sl), 2) +
    Math.pow(dCp / (Kc * Sc), 2) +
    Math.pow(dHp / (Kh * Sh), 2) +
    Rt * (dCp / (Kc * Sc)) * (dHp / (Kh * Sh))
  );
  return dE;
}

/* ---------- App state ---------- */
const fileInput = document.getElementById('fileInput');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const refA = document.getElementById('refA');
const refB = document.getElementById('refB');
const swatchA = document.getElementById('swatchA');
const swatchB = document.getElementById('swatchB');
const swatchPick = document.getElementById('swatchPick');
const pickedHexEl = document.getElementById('pickedHex');
const resultEl = document.getElementById('result');
const deltaMode = document.getElementById('deltaMode');
const avgMode = document.getElementById('avgMode');
const radiusEl = document.getElementById('radius');

/* ---------- Image handling ---------- */
function drawImageToCanvas(img) {
  const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
  const w = Math.round(img.width * scale);
  const h = Math.round(img.height * scale);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // center image
  const ox = Math.floor((canvas.width - w)/2);
  const oy = Math.floor((canvas.height - h)/2);
  ctx.drawImage(img, ox, oy, w, h);
}

fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = evt => {
    const img = new Image();
    img.onload = () => drawImageToCanvas(img);
    img.src = evt.target.result;
  };
  reader.readAsDataURL(file);
});

/* ---------- UI updates ---------- */
function updateSwatches() {
  const a = hexToRgb(refA.value);
  const b = hexToRgb(refB.value);
  swatchA.style.background = a ? rgbToHex(a) : '#fff';
  swatchB.style.background = b ? rgbToHex(b) : '#fff';
}
refA.addEventListener('input', updateSwatches);
refB.addEventListener('input', updateSwatches);
updateSwatches();

/* ---------- Picking color ---------- */
canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor(e.clientX - rect.left);
  const y = Math.floor(e.clientY - rect.top);

  const rad = parseInt(radiusEl.value || '1', 10);
  let rSum=0, gSum=0, bSum=0, count=0;

  if (avgMode.checked && rad > 1) {
    // average square radius around point
    for (let dy=-rad; dy<=rad; dy++) {
      for (let dx=-rad; dx<=rad; dx++) {
        const nx = x + dx, ny = y + dy;
        if (nx<0 || ny<0 || nx>=canvas.width || ny>=canvas.height) continue;
        const pix = ctx.getImageData(nx, ny, 1, 1).data;
        rSum += pix[0]; gSum += pix[1]; bSum += pix[2]; count++;
      }
    }
  } else {
    const pix = ctx.getImageData(x, y, 1, 1).data;
    rSum = pix[0]; gSum = pix[1]; bSum = pix[2]; count = 1;
  }

  const picked = { r: rSum / count, g: gSum / count, b: bSum / count };
  const pickedHex = rgbToHex(picked);
  swatchPick.style.background = pickedHex;
  pickedHexEl.textContent = `HEX: ${pickedHex}`;

  compareColors(picked);
});

/* ---------- Comparison ---------- */
function compareColors(pickedRgb) {
  const aRgb = hexToRgb(refA.value);
  const bRgb = hexToRgb(refB.value);
  if (!aRgb || !bRgb) {
    resultEl.innerHTML = '<strong>ผลลัพธ์:</strong> กรุณาเลือกสีต้นแบบให้ถูกต้อง';
    return;
  }

  const pLab = rgbToLab(pickedRgb);
  const aLab = rgbToLab(aRgb);
  const bLab = rgbToLab(bRgb);

  let dEA, dEB;
  if (deltaMode.value === '2000') {
    dEA = deltaE2000(pLab.L, pLab.a, pLab.b, aLab.L, aLab.a, aLab.b);
    dEB = deltaE2000(pLab.L, pLab.a, pLab.b, bLab.L, bLab.a, bLab.b);
  } else {
    dEA = deltaE76(pLab.L, pLab.a, pLab.b, aLab.L, aLab.a, aLab.b);
    dEB = deltaE76(pLab.L, pLab.a, pLab.b, bLab.L, bLab.a, bLab.b);
  }

  const closer = dEA < dEB ? 'สี A' : 'สี B';

  // --- คำนวณค่าตัวเลข ---
  const valA = parseFloat(document.getElementById("valA").value);
  const valB = parseFloat(document.getElementById("valB").value);
  let valPicked;

  if (dEA + dEB === 0) {
    valPicked = (valA + valB) / 2;
  } else {
    // interpolation: ยิ่ง ΔE น้อย ยิ่งใกล้ค่านั้น
    const weightA = 1 / (dEA + 0.0001);
    const weightB = 1 / (dEB + 0.0001);
    valPicked = (valA * weightA + valB * weightB) / (weightA + weightB);
  }

  resultEl.innerHTML = `
    <strong>ผลลัพธ์:</strong>
    <div>ΔE (A): ${dEA.toFixed(2)}</div>
    <div>ΔE (B): ${dEB.toFixed(2)}</div>
    <div>ใกล้กับ: ${closer}</div>
    <div>ค่าที่เลือก = ${valPicked.toFixed(2)}</div>
  `;
}
</script>

</body>
</html>